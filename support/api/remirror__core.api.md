## API Report File for "@remirror/core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { __INTERNAL_REMIRROR_IDENTIFIER_KEY__ } from '@remirror/core-constants';
import type { AnyConstructor } from '@remirror/core-types';
import type { AnyFunction } from '@remirror/core-types';
import type { ApplySchemaAttributes } from '@remirror/core-types';
import type { AttributesParameter } from '@remirror/core-types';
import type { CommandFunction } from '@remirror/core-types';
import { CreateDocumentErrorHandler } from '@remirror/core-utils';
import { CreateDocumentNodeParameter } from '@remirror/core-utils';
import type { CustomHandler } from '@remirror/core-types';
import type { CustomHandlerKeyList } from '@remirror/core-types';
import type { DirectEditorProps } from '@remirror/pm/view';
import type { Dispose } from '@remirror/core-types';
import type { EditorSchema } from '@remirror/core-types';
import type { EditorState } from '@remirror/core-types';
import { EditorState as EditorState_2 } from '@remirror/pm/state';
import type { EditorStateParameter } from '@remirror/core-types';
import type { EditorView } from '@remirror/core-types';
import type { EditorView as EditorView_2 } from '@remirror/pm/view';
import type { EditorViewParameter } from '@remirror/core-types';
import type { EmptyShape } from '@remirror/core-types';
import { ErrorConstant } from '@remirror/core-constants';
import type { Except } from 'type-fest';
import { ExtensionPriority } from '@remirror/core-constants';
import type { ExtensionTag } from '@remirror/core-constants';
import { Fallback } from '@remirror/core-utils';
import type { FromToParameter } from '@remirror/core-types';
import type { GetConstructorParameter } from '@remirror/core-types';
import type { GetCustomHandler } from '@remirror/core-types';
import type { GetDynamic } from '@remirror/core-types';
import type { GetFixedDynamic } from '@remirror/core-types';
import type { GetHandler } from '@remirror/core-types';
import type { GetPartialDynamic } from '@remirror/core-types';
import type { GetStatic } from '@remirror/core-types';
import type { HandlerKey } from '@remirror/core-types';
import type { HandlerKeyList } from '@remirror/core-types';
import type { IfEmpty } from '@remirror/core-types';
import type { IfHasRequiredProperties } from '@remirror/core-types';
import type { IfNoRequiredProperties } from '@remirror/core-types';
import type { KeyBindings } from '@remirror/core-types';
import type { MarkExtensionSpec } from '@remirror/core-types';
import type { MarkGroup } from '@remirror/core-constants';
import type { MarkType } from '@remirror/core-types';
import type { MarkTypeParameter } from '@remirror/core-types';
import type { NodeExtensionSpec } from '@remirror/core-types';
import type { NodeGroup } from '@remirror/core-constants';
import type { NodeType } from '@remirror/core-types';
import type { NonChainableCommandFunction } from '@remirror/core-utils';
import type { PluginSpec } from '@remirror/pm/state';
import type { PrimitiveSelection } from '@remirror/core-types';
import type { ProsemirrorAttributes } from '@remirror/core-types';
import type { RangeParameter } from '@remirror/core-types';
import type { RemirrorContentType } from '@remirror/core-types';
import { RemirrorIdentifier } from '@remirror/core-constants';
import type { RemirrorJSON } from '@remirror/core-types';
import type { RenderEnvironment } from '@remirror/core-types';
import type { Replace } from '@remirror/core-types';
import type { SchemaAttributes } from '@remirror/core-types';
import type { Shape } from '@remirror/core-types';
import type { StateJSON } from '@remirror/core-types';
import type { StaticKeyList } from '@remirror/core-types';
import { StringHandlerParameter } from '@remirror/core-utils';
import type { StringKey } from '@remirror/core-types';
import type { Suggester } from '@remirror/pm/suggest';
import type { SuggestState } from '@remirror/pm/suggest';
import type { TextParameter } from '@remirror/core-types';
import type { Transaction } from '@remirror/core-types';
import type { TransactionParameter } from '@remirror/core-types';
import type { TransactionTransformer } from '@remirror/core-types';
import type { UndefinedFlipPartialAndRequired } from '@remirror/core-types';
import type { UnionToIntersection } from 'type-fest';
import { Unsubscribe } from 'nanoevents';
import type { ValidOptions } from '@remirror/core-types';

// @public (undocumented)
export type ActiveFromCombined<Combined extends AnyCombinedUnion> = Record<GetNodeNameUnion<InferCombinedExtensions<Combined>>, (attributes?: ProsemirrorAttributes) => boolean> & Record<GetMarkNameUnion<InferCombinedExtensions<Combined>>, () => boolean>;

// @public (undocumented)
export type AddCustomHandler<Options extends ValidOptions> = (parameter: Partial<GetCustomHandler<Options>>) => Dispose | undefined;

// @public (undocumented)
export type AddHandler<Options extends ValidOptions> = <Key extends keyof GetHandler<Options>>(key: Key, method: GetHandler<Options>[Key]) => Dispose;

// @public (undocumented)
export type AnyCombinedUnion = CombinedUnion<AnyExtension, AnyPreset>;

// @public
export type AnyExtension = Replace<Extension<Shape>, Remirror.AnyExtensionOverrides> & object;

// @public
export type AnyExtensionConstructor = Replace<ExtensionConstructor<any>, {
    new (...args: any[]): AnyExtension;
}>;

// @public (undocumented)
export type AnyManagerStore = Remirror.ManagerStore<any>;

// @public
export type AnyMarkExtension = Replace<MarkExtension<Shape>, Remirror.AnyExtensionOverrides> & object;

// @public
export type AnyNodeExtension = Replace<NodeExtension<Shape>, Remirror.AnyExtensionOverrides> & object;

// @public
export type AnyPlainExtension = Replace<PlainExtension<Shape>, Remirror.AnyExtensionOverrides> & object;

// @public
export type AnyPreset = Replace<Preset<Shape>, Remirror.AnyPresetOverrides> & object;

// @public
export type AnyPresetConstructor = Replace<PresetConstructor<any>, {
    new (...args: any[]): AnyPreset;
}>;

// @public (undocumented)
export type AnyRemirrorManager = Replace<RemirrorManager<AnyCombinedUnion>, {
    clone: () => AnyRemirrorManager;
    store: Replace<Remirror.ManagerStore<any>, {
        chain: any;
    }>;
    ['~E']: AnyExtension;
    ['~P']: AnyPreset;
    ['~Sch']: EditorSchema;
    ['~N']: string;
    ['~M']: string;
    ['~EP']: AnyCombinedUnion;
    view: EditorView;
    addView: (view: EditorView) => void;
}>;

// @public (undocumented)
export type AttributePropFunction<Combined extends AnyCombinedUnion> = (params: RemirrorEventListenerParameter<Combined>) => Record<string, string>;

// @public
export class AttributesExtension extends PlainExtension {
    // (undocumented)
    get name(): "attributes";
    // @internal
    onCreate(): void;
    }

// @public (undocumented)
export abstract class BaseClass<Options extends ValidOptions = EmptyShape, DefaultStaticOptions extends Shape = EmptyShape> {
    ['~O']: Options & DefaultStaticOptions;
    // @internal
    abstract readonly [__INTERNAL_REMIRROR_IDENTIFIER_KEY__]: RemirrorIdentifier;
    constructor({ validator, defaultOptions, code }: BaseClassConstructorParameter<DefaultStaticOptions>, ...parameters: ConstructorParameter<Options, DefaultStaticOptions>);
    addCustomHandler<Key extends keyof GetCustomHandler<Options>>(key: Key, value: Required<GetCustomHandler<Options>>[Key]): Dispose;
    addHandler<Key extends keyof GetHandler<Options>>(key: Key, method: GetHandler<Options>[Key]): Dispose;
    abstract clone(...parameters: ConstructorParameter<Options, DefaultStaticOptions>): BaseClass<Options, DefaultStaticOptions>;
    static readonly customHandlerKeys: string[];
    static readonly defaultOptions: any;
    get dynamicKeys(): string[];
    static handlerKeyOptions: Partial<Record<string, HandlerKeyOptions> & {
        __ALL__?: HandlerKeyOptions;
    }>;
    static readonly handlerKeys: string[];
    protected init(): void;
    get initialOptions(): Readonly<Required<Options>> & DefaultStaticOptions;
    abstract get name(): string;
    protected onAddCustomHandler?: AddCustomHandler<Options>;
    protected onSetOptions?(parameter: OnSetOptionsParameter<Options>): void;
    get options(): Readonly<Required<Options>> & DefaultStaticOptions;
    resetOptions(): void;
    setOptions(update: GetPartialDynamic<Options>): void;
    static readonly staticKeys: string[];
    }

// @public (undocumented)
export interface BaseClass<Options extends ValidOptions, DefaultStaticOptions extends Shape = EmptyShape> {
    // (undocumented)
    constructor: BaseClassConstructor<Options, DefaultStaticOptions>;
}

// @public (undocumented)
export interface BaseClassConstructor<Options extends ValidOptions = EmptyShape, DefaultStaticOptions extends Shape = EmptyShape> extends Function {
    // @internal
    readonly [__INTERNAL_REMIRROR_IDENTIFIER_KEY__]: RemirrorIdentifier;
    // (undocumented)
    new (...parameters: ConstructorParameter<Options, DefaultStaticOptions>): any;
    readonly customHandlerKeys: string[];
    // @internal
    readonly defaultOptions: DefaultOptions<Options, DefaultStaticOptions>;
    readonly handlerKeyOptions: Partial<Record<string, HandlerKeyOptions> & {
        __ALL__?: HandlerKeyOptions;
    }>;
    readonly handlerKeys: string[];
    readonly staticKeys: string[];
}

// @public (undocumented)
export interface BaseExtensionOptions extends Remirror.BaseExtensionOptions {
    exclude?: ExcludeOptions;
    priority?: ExtensionPriority;
}

// @public (undocumented)
export interface BaseListenerParameter<Combined extends AnyCombinedUnion> extends EditorViewParameter<SchemaFromCombined<Combined>>, RemirrorGetterParameter {
    internalUpdate: boolean;
    tr?: Transaction<SchemaFromCombined<Combined>>;
}

// @public (undocumented)
export interface BuiltinOptions extends SuggestOptions, KeymapOptions {
}

// @public
export class BuiltinPreset extends Preset<BuiltinOptions> {
    // (undocumented)
    createExtensions(): (CommandsExtension | HelpersExtension | AttributesExtension | SchemaExtension | TagsExtension | PluginsExtension | InputRulesExtension | PasteRulesExtension | NodeViewsExtension | SuggestExtension | KeymapExtension)[];
    // (undocumented)
    get name(): "builtin";
    // (undocumented)
    protected onAddCustomHandler: AddCustomHandler<BuiltinOptions>;
    // (undocumented)
    protected onSetOptions(parameter: OnSetOptionsParameter<BuiltinOptions>): void;
}

// @public (undocumented)
export interface ChainedCommandRunParameter {
    run: () => void;
}

// @public (undocumented)
export type ChainedFromCombined<Combined extends AnyCombinedUnion> = ChainedFromExtensions<InferCombinedExtensions<Combined>>;

// @public (undocumented)
export type ChainedFromExtensions<ExtensionUnion extends AnyExtension> = ChainedCommandRunParameter & {
    [Command in keyof ChainedIntersection<ExtensionUnion>]: ChainedIntersection<ExtensionUnion>[Command] extends (...args: any[]) => any ? (...args: Parameters<ChainedIntersection<ExtensionUnion>[Command]>) => ChainedFromExtensions<ExtensionUnion> : never;
};

// @public (undocumented)
export type ChainedIntersection<ExtensionUnion extends AnyExtension> = UnionToIntersection<MapToChainedCommand<GetCommands<ExtensionUnion>>>;

// @public
export type ChangedOptions<Options extends ValidOptions> = {
    [Key in keyof GetDynamic<Options>]: Changes<GetDynamic<Options>[Key]>;
};

// @public (undocumented)
export type CombinedUnion<ExtensionUnion extends AnyExtension, PresetUnion extends AnyPreset> = ExtensionUnion | PresetUnion;

// @public
export type CommandNames<ExtensionUnion extends AnyExtension> = StringKey<CommandsFromExtensions<ExtensionUnion>>;

// @public
export class CommandsExtension extends PlainExtension {
    createCommands(): {
        customTransaction(transactionUpdater: (transaction: Transaction) => void): CommandFunction;
        insertText(text: string): CommandFunction;
        delete(range?: FromToParameter): CommandFunction;
        emptyUpdate: () => CommandFunction;
        forceUpdate: (...keys: UpdatableViewProps[]) => CommandFunction;
        updateNodeAttributes: <Type extends object>(pos: number, attrs: ProsemirrorAttributes<Type>) => CommandFunction;
    };
    createPlugin(): CreatePluginReturn;
    // (undocumented)
    get name(): "commands";
    // (undocumented)
    onCreate(): void;
    onStateUpdate({ state }: StateUpdateLifecycleParameter): void;
    // (undocumented)
    onView(view: EditorView_2<EditorSchema>): void;
    get transaction(): Transaction;
    }

// @public (undocumented)
export type CommandsFromCombined<Combined extends AnyCombinedUnion> = CommandsFromExtensions<InferCombinedExtensions<Combined>>;

// @public
export type CommandsFromExtensions<ExtensionUnion extends AnyExtension> = UnionToIntersection<MapToUnchainedCommand<GetCommands<ExtensionUnion>>>;

// @public
export interface CommandShape<Parameter extends any[] = []> {
    // (undocumented)
    (...args: Parameter): void;
    isEnabled: (attrs?: ProsemirrorAttributes) => boolean;
}

// @public
export interface CreatePluginReturn<PluginState = any> extends Except<PluginSpec<PluginState, EditorSchema>, 'key'> {
}

// @public (undocumented)
export type CreateStateFromContent<Combined extends AnyCombinedUnion> = (content: RemirrorContentType, selection?: FromToParameter) => EditorState<SchemaFromCombined<Combined>>;

// @internal (undocumented)
export type CustomHandlerMethod<Options extends ValidOptions> = <Key extends keyof GetCustomHandler<Options>>(key: Key, value: Required<GetCustomHandler<Options>>[Key]) => Dispose;

// @public
export type DefaultExtensionOptions<Options extends ValidOptions> = DefaultOptions<Options, BaseExtensionOptions>;

// @public
export type DefaultPresetOptions<Options extends ValidOptions> = DefaultOptions<Options, EmptyShape>;

// @public
export type DynamicOptionsOfConstructor<Constructor extends AnyConstructor> = GetPartialDynamic<GetOptions<InstanceType<Constructor>>>;

// @public (undocumented)
export const editorStyles: string;

// @public (undocumented)
export abstract class EditorWrapper<Combined extends AnyCombinedUnion, Props extends EditorWrapperProps<Combined>> {
    constructor(parameter: EditorWrapperParameter<Combined, Props>);
    protected addFocusListeners(): void;
    protected baseListenerParameter(parameter: ListenerParameter<Combined>): BaseListenerParameter<Combined>;
    protected readonly blur: () => void;
    protected abstract createView(state: EditorState<SchemaFromCombined<Combined>>, element?: Element): EditorView<SchemaFromCombined<Combined>>;
    protected readonly dispatchTransaction: (tr: Transaction) => void;
    protected get doc(): any;
    // (undocumented)
    get editorWrapperOutput(): EditorWrapperOutput<Combined>;
    protected eventListenerParameter(parameter?: ListenerParameter<Combined>): RemirrorEventListenerParameter<Combined>;
    protected readonly focus: (position?: FocusType) => void;
    protected getAttributes(ssr?: false): Record<string, string>;
    // (undocumented)
    protected getAttributes(ssr: true): Shape;
    protected readonly getPreviousState: () => Readonly<import("@remirror/pm/state").EditorState<EditorSchema<import("./extension").GetNodeNameUnion<import("./preset").InferCombinedExtensions<Combined>>, import("./extension").GetMarkNameUnion<import("./preset").InferCombinedExtensions<Combined>>>>>;
    protected readonly getState: () => import("@remirror/pm/state").EditorState<EditorSchema<import("./extension").GetNodeNameUnion<import("./preset").InferCombinedExtensions<Combined>>, import("./extension").GetMarkNameUnion<import("./preset").InferCombinedExtensions<Combined>>>>;
    protected get manager(): RemirrorManager<Combined>;
    readonly onChange: (parameter?: ListenerParameter<Combined>) => void;
    onDestroy(): void;
    protected get previousState(): EditorState<SchemaFromCombined<Combined>>;
    protected previousStateOverride?: EditorState<SchemaFromCombined<Combined>>;
    get props(): Props;
    protected removeFocusListeners(): void;
    // (undocumented)
    protected get uid(): string;
    protected get updatableViewProps(): UpdatableViewPropsObject;
    update(parameter: EditorWrapperParameter<Combined, Props>): this;
    protected abstract updateState(parameter: UpdateStateParameter<SchemaFromCombined<Combined>>): void;
    protected updateViewProps(...keys: UpdatableViewProps[]): void;
    protected get view(): EditorView<SchemaFromCombined<Combined>>;
}

// @public
export interface EditorWrapperOutput<Combined extends AnyCombinedUnion> extends Remirror.ManagerStore<Combined> {
    addHandler: <Key extends keyof EditorWrapperEvents<Combined>>(event: Key, cb: EditorWrapperEvents<Combined>[Key]) => Unsubscribe;
    blur: () => void;
    clearContent: (options?: TriggerChangeParameter) => void;
    focus: (position?: FocusType) => void;
    getExtension: <ExtensionConstructor extends AnyExtensionConstructor>(Constructor: ExtensionConstructor) => InstanceType<ExtensionConstructor>;
    getPreset: <PresetConstructor extends AnyPresetConstructor>(Constructor: PresetConstructor) => InstanceType<PresetConstructor>;
    getPreviousState: () => EditorState<SchemaFromCombined<Combined>>;
    getState: () => EditorState<SchemaFromCombined<Combined>>;
    manager: RemirrorManager<Combined>;
    setContent: (content: RemirrorContentType, options?: TriggerChangeParameter) => void;
    uid: string;
}

// @public (undocumented)
export interface EditorWrapperParameter<Combined extends AnyCombinedUnion, Props extends EditorWrapperProps<Combined>> {
    createStateFromContent: CreateStateFromContent<Combined>;
    element?: Element;
    getProps: () => Props;
    initialEditorState: EditorState<SchemaFromCombined<Combined>>;
}

// @public
export interface EditorWrapperProps<Combined extends AnyCombinedUnion> extends StringHandlerParameter {
    attributes?: Record<string, string> | AttributePropFunction<Combined>;
    autoFocus?: FocusType;
    editable?: boolean;
    forceEnvironment?: RenderEnvironment;
    initialContent?: RemirrorContentType | [RemirrorContentType, PrimitiveSelection];
    label?: string;
    manager: RemirrorManager<any>;
    onBlur?: (params: RemirrorEventListenerParameter<Combined>, event: Event) => void;
    onChange?: RemirrorEventListener<Combined>;
    onDispatchTransaction?: TransactionTransformer<SchemaFromCombined<Combined>>;
    onError?: Fallback | CreateDocumentErrorHandler;
    onFocus?: (params: RemirrorEventListenerParameter<Combined>, event: Event) => void;
}

// @public (undocumented)
export interface ExcludeOptions extends Partial<Remirror.ExcludeOptions> {
}

// @public
export abstract class Extension<Options extends ValidOptions = EmptyShape> extends BaseClass<Options, BaseExtensionOptions> {
    constructor(...parameters: ExtensionConstructorParameter<Options>);
    clone(...parameters: ExtensionConstructorParameter<Options>): Extension<Options>;
    static readonly defaultPriority: ExtensionPriority;
    isOfType<Type extends AnyExtensionConstructor>(Constructor: Type): this is InstanceType<Type>;
    get priority(): ExtensionPriority;
    setPriority(priority: undefined | ExtensionPriority): void;
    // @internal
    setStore(store: Remirror.ExtensionStore): void;
    protected get store(): Readonly<Remirror.ExtensionStore>;
}

// @public
export interface Extension<Options extends ValidOptions = EmptyShape> extends ExtensionLifecycleMethods, Remirror.ExtensionCreatorMethods, Remirror.BaseExtension {
    // (undocumented)
    constructor: ExtensionConstructor<Options>;
    requiredExtensions?: object[];
}

// @public (undocumented)
export type ExtensionCommandFunction = (...args: any[]) => CommandFunction<EditorSchema>;

// @public
export interface ExtensionCommandReturn {
    // (undocumented)
    [command: string]: ExtensionCommandFunction;
}

// @public (undocumented)
export interface ExtensionConstructor<Options extends ValidOptions = EmptyShape> extends BaseClassConstructor<Options, BaseExtensionOptions>, Partial<Remirror.StaticExtensionOptions> {
    // (undocumented)
    new (...parameters: ExtensionConstructorParameter<Options>): Extension<Options>;
    readonly defaultPriority: ExtensionPriority;
}

// @public
export type ExtensionConstructorParameter<Options extends ValidOptions> = ConstructorParameter<Options, BaseExtensionOptions>;

// @public
export function extensionDecorator<Options extends Shape = EmptyShape>(options: ExtensionDecoratorOptions<Options>): <Type extends import("@remirror/core-types").Replace<ExtensionConstructor<any>, new (...args: any[]) => import("./extension").AnyExtension>>(ReadonlyConstructor: Type) => Type;

// @public (undocumented)
export type ExtensionDecoratorOptions<Options extends Shape = EmptyShape> = DefaultPriorityParameter & IfHasRequiredProperties<DefaultExtensionOptions<Options>, DefaultOptionsParameter<Options>, Partial<DefaultOptionsParameter<Options>>> & IfEmpty<GetStatic<Options>, Partial<StaticKeysParameter<Options>>, StaticKeysParameter<Options>> & IfEmpty<GetHandler<Options>, Partial<HandlerKeysParameter<Options>>, HandlerKeysParameter<Options>> & IfEmpty<GetCustomHandler<Options>, Partial<CustomHandlerKeysParameter<Options>>, CustomHandlerKeysParameter<Options>> & Partial<Remirror.StaticExtensionOptions>;

// @public
export interface ExtensionHelperReturn {
    // (undocumented)
    [helper: string]: AnyFunction;
}

// @public (undocumented)
export interface ExtensionListParameter<ExtensionUnion extends AnyExtension = AnyExtension> {
    readonly extensions: readonly ExtensionUnion[];
}

// @public
export interface ExtensionStore extends Remirror.ExtensionStore {
}

// @public
export interface ExtensionTags<ExtensionUnion extends AnyExtension> {
    general: GeneralExtensionTags<GetNameUnion<ExtensionUnion>>;
    mark: MarkExtensionTags<GetMarkNameUnion<ExtensionUnion>>;
    node: NodeExtensionTags<GetNodeNameUnion<ExtensionUnion>>;
}

// @public
export type FocusType = PrimitiveSelection | boolean;

// @public
export type GeneralExtensionTags<Names extends string = string> = Record<ExtensionTag, Names[]> & Record<string, undefined | Names[]>;

// @public (undocumented)
export interface GetChangeOptionsReturn<Options extends ValidOptions> {
    changes: Readonly<Required<ChangedOptions<Options>>>;
    options: GetFixedDynamic<Options>;
    pickChanged: PickChanged<Options>;
}

// @public (undocumented)
export type GetCombined<Manager extends AnyRemirrorManager> = Manager['~EP'];

// @public
export type GetCommands<Type extends {
    ['~C']: unknown;
}> = Type['~C'];

// @public
export type GetConstructor<Type extends {
    constructor: unknown;
}> = Type['constructor'];

// @public
export type GetExtensions<Type extends {
    ['~E']: unknown;
}> = Type['~E'];

// @public
export type GetExtensionUnion<Type extends ExtensionListParameter> = Type['extensions'][number];

// @public
export type GetHelpers<Type extends {
    ['~H']: unknown;
}> = Type['~H'];

// @public
export type GetMarkNameUnion<ExtensionUnion extends AnyExtension> = ExtensionUnion extends AnyMarkExtension ? ExtensionUnion['name'] : never;

// @public
export type GetNameUnion<Type extends {
    name: string;
}> = Type['name'];

// @public
export type GetNodeNameUnion<ExtensionUnion extends AnyExtension> = ExtensionUnion extends AnyNodeExtension ? ExtensionUnion['name'] : never;

// @public
export type GetOptions<Type extends {
    ['~O']: unknown;
}> = Type['~O'];

// @public
export type GetPlainNames<Type> = Type extends AnyPlainExtension ? GetNameUnion<Type> : never;

// @public
export type GetPresetUnion<Type extends {
    presets: any[];
}> = Type['presets'][number];

// @public
export type GetSchema<Type extends {
    ['~Sch']: unknown;
}> = Type['~Sch'];

// @public (undocumented)
export interface HandlerKeyOptions {
    earlyReturnValue?: unknown;
}

// @public
export type HelperNames<ExtensionUnion extends AnyExtension> = StringKey<HelpersFromExtensions<ExtensionUnion>>;

// @public
export class HelpersExtension extends PlainExtension {
    // (undocumented)
    createHelpers(): {};
    // (undocumented)
    get name(): "helpers";
    onCreate(): void;
    onView(): void;
}

// @public (undocumented)
export type HelpersFromCombined<Combined extends AnyCombinedUnion> = HelpersFromExtensions<InferCombinedExtensions<Combined>>;

// @public
export type HelpersFromExtensions<ExtensionUnion extends AnyExtension> = UnionToIntersection<MapHelpers<GetHelpers<ExtensionUnion>>>;

// @public
export type Identifiers = 'nodes' | 'marks' | 'all' | readonly string[];

// @public
export interface IdentifierSchemaAttributes {
    attributes: SchemaAttributes;
    identifiers: Identifiers;
}

// @public (undocumented)
export type InferCombinedExtensions<Combined extends AnyCombinedUnion> = Combined extends AnyExtension ? Combined : Combined extends AnyPreset ? GetExtensions<Combined> : never;

// @public (undocumented)
export type InferCombinedPresets<Combined extends AnyCombinedUnion> = Combined extends AnyPreset ? Combined : never;

// @public
export class InputRulesExtension extends PlainExtension {
    // (undocumented)
    get name(): "inputRules";
    onCreate(): void;
    }

// @public
export function isExtension<Type extends AnyExtension = AnyExtension>(value: unknown): value is Type;

// @public
export function isExtensionConstructor<Type extends AnyExtensionConstructor = AnyExtensionConstructor>(value: unknown): value is Type;

// @public
export function isMarkExtension<Type extends AnyMarkExtension = AnyMarkExtension>(value: unknown): value is Type;

// @public
export function isNodeExtension<Type extends AnyNodeExtension = AnyNodeExtension>(value: unknown): value is Type;

// @public
export function isPlainExtension<Type extends AnyPlainExtension = AnyPlainExtension>(value: unknown): value is Type;

// @public
export function isPreset<Type extends AnyPreset = AnyPreset>(value: unknown): value is Type;

// @public
export function isPresetConstructor<Type extends AnyPresetConstructor = AnyPresetConstructor>(value: unknown): value is Type;

// @public
export function isRemirrorManager<Combined extends AnyCombinedUnion = AnyCombinedUnion>(value: unknown): value is RemirrorManager<Combined>;

// @public
export function isValidExtensionConstructor(Constructor: unknown): asserts Constructor is AnyExtensionConstructor;

// @public
export class KeymapExtension extends PlainExtension<KeymapOptions> {
    createKeymap: () => Record<string, import("@remirror/core-types").CommandFunction<import("@remirror/core-types").EditorSchema<string, string>, import("@remirror/core-types").NextParameter<import("@remirror/core-types").EditorSchema<string, string>>>>;
    // (undocumented)
    get name(): "keymap";
    protected onAddCustomHandler: AddCustomHandler<KeymapOptions>;
    onCreate(): void;
    protected onSetOptions(parameter: OnSetOptionsParameter<KeymapOptions>): void;
    }

// @public (undocumented)
export interface KeymapOptions {
    excludeBaseKeymap?: boolean;
    keymap?: CustomHandler<KeyBindings>;
    selectParentNodeOnEscape?: boolean;
    undoInputRuleOnBackspace?: boolean;
}

// @public (undocumented)
export interface ListenerParameter<Combined extends AnyCombinedUnion> extends Partial<EditorStateParameter<SchemaFromCombined<Combined>>>, Partial<TransactionParameter<SchemaFromCombined<Combined>>> {
}

// @public (undocumented)
export interface ManagerEvents {
    destroy: () => void;
    stateUpdate: (parameter: StateUpdateLifecycleParameter) => void;
}

// @public (undocumented)
export type ManagerStoreKeys = keyof Remirror.ManagerStore<any>;

// @public
export type MapHelpers<RawHelpers extends Record<string, AnyFunction>> = {
    [Helper in keyof RawHelpers]: RawHelpers[Helper];
};

// @public
export abstract class MarkExtension<Options extends ValidOptions = EmptyShape> extends Extension<Options> {
    // (undocumented)
    static get [__INTERNAL_REMIRROR_IDENTIFIER_KEY__](): RemirrorIdentifier.MarkExtensionConstructor;
    // (undocumented)
    get [__INTERNAL_REMIRROR_IDENTIFIER_KEY__](): RemirrorIdentifier.MarkExtension;
    constructor(...parameters: ExtensionConstructorParameter<Options>);
    abstract createMarkSpec(extra: ApplySchemaAttributes): MarkExtensionSpec;
    static readonly disableExtraAttributes: boolean;
    get type(): MarkType;
}

// @public (undocumented)
export interface MarkExtension<Options extends ValidOptions = EmptyShape> extends Extension<Options>, Remirror.MarkExtension {
}

// @public
export type MarkExtensionTags<MarkNames extends string = string> = Record<MarkGroup, MarkNames[]> & Record<string, undefined | MarkNames[]>;

// @public
export function mutateDefaultExtensionOptions(mutatorMethod: (defaultOptions: BaseExtensionOptions) => void): void;

// @public
export abstract class NodeExtension<Options extends ValidOptions = EmptyShape> extends Extension<Options> {
    // (undocumented)
    static get [__INTERNAL_REMIRROR_IDENTIFIER_KEY__](): RemirrorIdentifier.NodeExtensionConstructor;
    // (undocumented)
    get [__INTERNAL_REMIRROR_IDENTIFIER_KEY__](): RemirrorIdentifier.NodeExtension;
    constructor(...parameters: ExtensionConstructorParameter<Options>);
    abstract createNodeSpec(extra: ApplySchemaAttributes): NodeExtensionSpec;
    static readonly disableExtraAttributes: boolean;
    get type(): NodeType;
}

// @public (undocumented)
export interface NodeExtension<Options extends ValidOptions = EmptyShape> extends Extension<Options>, Remirror.NodeExtension {
}

// @public
export type NodeExtensionTags<NodeNames extends string = string> = Record<NodeGroup, NodeNames[]> & Record<string, undefined | NodeNames[]>;

// @public
export class NodeViewsExtension extends PlainExtension {
    // (undocumented)
    get name(): "nodeView";
    onCreate(): void;
}

// @public (undocumented)
export interface OnSetOptionsParameter<Options extends ValidOptions> extends Pick<GetChangeOptionsReturn<Options>, 'changes' | 'pickChanged'>, UpdateReasonParameter {
    initialOptions: GetFixedDynamic<Options>;
    options: GetFixedDynamic<Options>;
}

// @public
export type OptionsOfConstructor<Constructor extends AnyConstructor> = GetOptions<InstanceType<Constructor>>;

// @public
export class PasteRulesExtension extends PlainExtension {
    // (undocumented)
    get name(): "pasteRules";
    onCreate(): void;
}

// @public (undocumented)
export type PickChanged<Options> = <Key extends keyof GetFixedDynamic<Options>>(keys: Key[]) => Partial<Pick<GetFixedDynamic<Options>, Key>>;

// @public (undocumented)
export interface PlaceholderConfig extends TextParameter {
    // (undocumented)
    className: string;
}

// @public
export abstract class PlainExtension<Options extends ValidOptions = EmptyShape> extends Extension<Options> {
    // (undocumented)
    static get [__INTERNAL_REMIRROR_IDENTIFIER_KEY__](): RemirrorIdentifier.PlainExtensionConstructor;
    // (undocumented)
    get [__INTERNAL_REMIRROR_IDENTIFIER_KEY__](): RemirrorIdentifier.PlainExtension;
}

// @public
export class PluginsExtension extends PlainExtension {
    // (undocumented)
    get name(): "plugins";
    // (undocumented)
    onCreate(): void;
    }

// @public
export abstract class Preset<Options extends ValidOptions = EmptyShape> extends BaseClass<Options, object> {
    // @internal
    static get [__INTERNAL_REMIRROR_IDENTIFIER_KEY__](): RemirrorIdentifier.PresetConstructor;
    // @internal
    get [__INTERNAL_REMIRROR_IDENTIFIER_KEY__](): RemirrorIdentifier.Preset;
    constructor(...parameters: PresetConstructorParameter<Options>);
    clone(...parameters: PresetConstructorParameter<Options>): Preset<Options>;
    abstract createExtensions(): AnyExtension[];
    static readonly defaultOptions: {};
    // (undocumented)
    get extensions(): this["~E"][];
    protected get extensionStore(): Readonly<Remirror.ExtensionStore>;
    getExtension<Type extends this['~E']['constructor']>(Constructor: Type): InstanceType<Type>;
    isOfType<Type extends AnyPresetConstructor>(Constructor: Type): this is InstanceType<Type>;
    abstract readonly name: string;
    protected abstract onSetOptions(parameter: OnSetOptionsParameter<Options>): void;
    replaceExtension(constructor: AnyExtensionConstructor, extension: this['~E']): void;
    // @internal
    setExtensionStore(store: Remirror.ExtensionStore): void;
}

// @public (undocumented)
export interface Preset<Options extends ValidOptions = EmptyShape> {
    ['~E']: ReturnType<this['createExtensions']>[number];
    ['~P']: Options;
    ['~S']: Options;
    constructor: PresetConstructor<Options>;
}

// @public
export interface PresetConstructor<Options extends ValidOptions = EmptyShape> extends BaseClassConstructor {
    // @internal
    readonly [__INTERNAL_REMIRROR_IDENTIFIER_KEY__]: RemirrorIdentifier;
    // (undocumented)
    new (...args: PresetConstructorParameter<Options>): Preset<Options>;
    readonly defaultOptions: DefaultPresetOptions<Options>;
}

// @public
export type PresetConstructorParameter<Options extends ValidOptions> = ConstructorParameter<Options, EmptyShape>;

// @public
export function presetDecorator<Options extends Shape = EmptyShape>(options: PresetDecoratorOptions<Options>): <Type extends import("@remirror/core-types").Replace<PresetConstructor<any>, new (...args: any[]) => import("./preset").AnyPreset>>(ReadonlyConstructor: Type) => Type;

// @public (undocumented)
export type PresetDecoratorOptions<Options extends Shape = EmptyShape> = IfHasRequiredProperties<DefaultPresetOptions<Options>, DefaultOptionsParameter<Options>, Partial<DefaultOptionsParameter<Options>>> & IfEmpty<GetStatic<Options>, Partial<StaticKeysParameter<Options>>, StaticKeysParameter<Options>> & IfEmpty<GetHandler<Options>, Partial<HandlerKeysParameter<Options>>, HandlerKeysParameter<Options>> & IfEmpty<GetCustomHandler<Options>, Partial<CustomHandlerKeysParameter<Options>>, CustomHandlerKeysParameter<Options>>;

// @public (undocumented)
export interface PresetListParameter<PresetUnion extends AnyPreset> {
    // (undocumented)
    presets: PresetUnion[];
}

// @public (undocumented)
export interface PresetParameter<PresetUnion extends AnyPreset> {
    // (undocumented)
    preset: PresetUnion;
}

// @public (undocumented)
export type RemirrorEventListener<Combined extends AnyCombinedUnion> = (params: RemirrorEventListenerParameter<Combined>) => void;

// @public (undocumented)
export interface RemirrorEventListenerParameter<Combined extends AnyCombinedUnion> extends EditorStateParameter<SchemaFromCombined<Combined>>, BaseListenerParameter<Combined> {
    createStateFromContent: CreateStateFromContent<Combined>;
    firstRender: boolean;
    previousState: EditorState<SchemaFromCombined<Combined>>;
}

// @public (undocumented)
export interface RemirrorGetterParameter {
    getHTML: () => string;
    getJSON: () => StateJSON;
    getRemirrorJSON: () => RemirrorJSON;
    getText: (lineBreakDivider?: string) => string;
}

// @public
export class RemirrorManager<Combined extends AnyCombinedUnion> {
    // @internal
    get [__INTERNAL_REMIRROR_IDENTIFIER_KEY__](): RemirrorIdentifier.Manager;
    addHandler<Key extends keyof ManagerEvents>(event: Key, cb: ManagerEvents[Key]): Unsubscribe;
    addView(view: EditorView<this['~Sch']>): this;
    clone(): RemirrorManager<Combined>;
    get combined(): readonly Combined[];
    static create<Combined extends AnyCombinedUnion>(combined: Combined[] | (() => Combined[]), settings?: Remirror.ManagerSettings): RemirrorManager<BuiltinPreset | Combined>;
    createState(parameter: Omit<CreateDocumentNodeParameter, 'schema'>): EditorState_2<any>;
    destroy(): void;
    get destroyed(): boolean;
    get extensions(): ReadonlyArray<GetExtensions<this>>;
    get extensionTags(): Readonly<import("../extension").ExtensionTags<InferCombinedExtensions<Combined>>>;
    static fromObject<ExtensionUnion extends AnyExtension, PresetUnion extends AnyPreset>({ extensions, presets, settings, }: RemirrorManagerParameter<ExtensionUnion, PresetUnion>): RemirrorManager<BuiltinPreset | ExtensionUnion | PresetUnion>;
    getExtension<ExtensionConstructor extends AnyExtensionConstructor>(Constructor: ExtensionConstructor): InstanceType<ExtensionConstructor>;
    getPreset<PresetConstructor extends AnyPresetConstructor>(Constructor: PresetConstructor): InstanceType<PresetConstructor>;
    get marks(): Record<GetMarkNameUnion<InferCombinedExtensions<Combined>>, import("@remirror/core-types").MarkExtensionSpec>;
    get mounted(): boolean;
    get nodes(): Record<GetNodeNameUnion<InferCombinedExtensions<Combined>>, import("@remirror/core-types").NodeExtensionSpec>;
    onStateUpdate(parameter: Omit<StateUpdateLifecycleParameter, 'firstUpdate'>): void;
    get presets(): readonly this["~P"][];
    recreate<ExtraCombined extends AnyCombinedUnion>(combined?: ExtraCombined[], settings?: Remirror.ManagerSettings): RemirrorManager<Combined | ExtraCombined>;
    get schema(): EditorSchema<GetNodeNameUnion<InferCombinedExtensions<Combined>>, GetMarkNameUnion<InferCombinedExtensions<Combined>>>;
    get settings(): Remirror.ManagerSettings;
    get store(): Readonly<Remirror.ManagerStore<Combined>>;
    get view(): EditorView<EditorSchema<GetNodeNameUnion<InferCombinedExtensions<Combined>>, GetMarkNameUnion<InferCombinedExtensions<Combined>>>>;
}

// @public (undocumented)
export interface RemirrorManager<Combined extends AnyCombinedUnion> {
    ['~E']: InferCombinedExtensions<Combined>;
    // (undocumented)
    ['~EP']: Combined;
    // @internal
    ['~M']: GetMarkNameUnion<this['~E']>;
    // @internal
    ['~N']: GetNodeNameUnion<this['~E']>;
    ['~P']: InferCombinedPresets<Combined>;
    ['~Sch']: SchemaFromCombined<Combined>;
    constructor: RemirrorManagerConstructor;
}

// @public (undocumented)
export interface RemirrorManagerParameter<ExtensionUnion extends AnyExtension, PresetUnion extends AnyPreset> {
    extensions: ExtensionUnion[];
    presets: PresetUnion[];
    settings?: Remirror.ManagerSettings;
}

// @public
export class SchemaExtension extends PlainExtension {
    // (undocumented)
    get name(): "schema";
    // (undocumented)
    onCreate(): void;
}

// @public (undocumented)
export type SchemaFromCombined<Combined extends AnyCombinedUnion> = SchemaFromExtensionUnion<InferCombinedExtensions<Combined>>;

// @public
export type SchemaFromExtensionUnion<ExtensionUnion extends AnyExtension> = EditorSchema<GetNodeNameUnion<ExtensionUnion>, GetMarkNameUnion<ExtensionUnion>>;

// @public (undocumented)
export interface StateUpdateLifecycleParameter extends EditorStateParameter {
    firstUpdate: boolean;
    previousState: EditorState;
    tr?: Transaction;
    transactions?: Transaction[];
}

// @public
export class SuggestExtension extends PlainExtension<SuggestOptions> {
    // (undocumented)
    createHelpers(): {
        getSuggestPluginState: () => SuggestState;
        getSuggestPluginHelpers: () => {
            addIgnored: ({ from, char, name, specific }: import("@remirror/pm/suggest").AddIgnoredParameter) => void;
            clearIgnored: (name?: string) => void;
            removeIgnored: ({ from, char, name }: import("@remirror/pm/suggest").RemoveIgnoredParameter) => void;
            ignoreNextExit: () => void;
            setMarkRemoved: () => void;
        };
    };
    // (undocumented)
    get name(): "suggestions";
    // (undocumented)
    onAddCustomHandler: AddCustomHandler<SuggestOptions>;
    onCreate: () => void;
}

// @public (undocumented)
export interface SuggestOptions {
    suggester: CustomHandler<Suggester>;
}

// @public
export class TagsExtension extends PlainExtension {
    // (undocumented)
    get combinedTags(): {
        general: GeneralExtensionTags<string>;
        mark: MarkExtensionTags<string>;
        node: NodeExtensionTags<string>;
    };
    // (undocumented)
    get name(): "tags";
    // (undocumented)
    onCreate(): void;
    }

// @public
export function toggleMark(parameter: ToggleMarkParameter): CommandFunction;

// @public (undocumented)
export interface TriggerChangeParameter {
    triggerChange?: boolean;
}

// @public (undocumented)
export type UpdatableViewProps = 'attributes' | 'editable' | 'nodeViews';

// @internal (undocumented)
export type UpdateReason = 'set' | 'reset';

// @public (undocumented)
export interface UpdateReasonParameter {
    reason: UpdateReason;
}

// @public (undocumented)
export interface UpdateStateParameter<Schema extends EditorSchema = any> extends Partial<TransactionParameter<Schema>>, EditorStateParameter<Schema>, TriggerChangeParameter {
    transactions?: Array<Transaction<Schema>>;
}


export * from "@remirror/core-constants";
export * from "@remirror/core-helpers";
export * from "@remirror/core-types";
export * from "@remirror/core-utils";

// (No @packageDocumentation comment for this package)

```
