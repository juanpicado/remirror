## API Report File for "@remirror/core-types"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { __INTERNAL_REMIRROR_IDENTIFIER_KEY__ } from '@remirror/core-constants';
import type { ConditionalExcept } from 'type-fest';
import type { ConditionalPick } from 'type-fest';
import type { Decoration as Decoration_2 } from '@remirror/pm/view';
import type { DecorationSet as DecorationSet_2 } from '@remirror/pm/view';
import type { EditorState as EditorState_2 } from '@remirror/pm/state';
import type { EditorView as EditorView_2 } from '@remirror/pm/view';
import type { Fragment as Fragment_2 } from '@remirror/pm/model';
import type { InputRule as InputRule_2 } from '@remirror/pm/inputrules';
import type { Mapping as Mapping_2 } from '@remirror/pm/transform';
import type { Mark as Mark_2 } from '@remirror/pm/model';
import type { MarkSpec } from '@remirror/pm/model';
import type { MarkType as MarkType_2 } from '@remirror/pm/model';
import type { Node as Node_2 } from '@remirror/pm/model';
import type { NodeSpec } from '@remirror/pm/model';
import type { NodeType as NodeType_2 } from '@remirror/pm/model';
import type { NodeView as NodeView_2 } from '@remirror/pm/view';
import type { Plugin as Plugin_3 } from '@remirror/pm/state';
import type { PluginKey as PluginKey_2 } from '@remirror/pm/state';
import type { RemirrorIdentifier } from '@remirror/core-constants';
import type { ResolvedPos as ResolvedPos_2 } from '@remirror/pm/model';
import type { Schema } from '@remirror/pm/model';
import type { Selection as Selection_3 } from '@remirror/pm/state';
import type { Slice as Slice_2 } from '@remirror/pm/model';
import type { Transaction as Transaction_2 } from '@remirror/pm/state';

// @public
export type And<Type extends Shape, Other extends Shape> = Type & Other;

// @public
export type AnyConstructor<Type = any> = new (...args: any[]) => Type;

// @public
export type AnyFunction<Type = any> = (...args: any[]) => Type;

// @public (undocumented)
export interface ApplySchemaAttributes {
    defaults: () => Record<string, {
        default: string | null;
    }>;
    dom: (attrs: ProsemirrorNode | Mark) => Record<string, string>;
    parse: (domNode: Node | string) => ProsemirrorAttributes;
}

// @public
export interface AttributesParameter {
    attrs: ProsemirrorAttributes;
}

// @public (undocumented)
export type AttributesWithClass = ProsemirrorAttributes & {
    class?: string;
};

// @public
export type Brand<Type, B> = Type & Branding<B>;

// @public (undocumented)
export interface CallbackParameter {
    callback: () => void;
}

// @public
export type ChainedCommandFunction<Schema extends EditorSchema = any> = (transaction: TransactionParameter<Schema>) => void;

// @public
export type CommandFunction<Schema extends EditorSchema = any, ExtraParameter extends object = object> = (params: CommandFunctionParameter<Schema> & ExtraParameter) => boolean;

// @public
export interface CommandFunctionParameter<Schema extends EditorSchema = any> extends Partial<EditorViewParameter<Schema>>, EditorStateParameter<Schema>, TransactionParameter<Schema> {
    dispatch?: DispatchFunction<Schema>;
}

// @public
export interface CompareStateParameter<Schema extends EditorSchema = EditorSchema> {
    newState: EditorState<Schema>;
    oldState: EditorState<Schema>;
}

// @public
export type CustomHandler<Type> = Type & CustomHandlerAnnotation;

// @public (undocumented)
export type CustomHandlerKey<Options extends ValidOptions> = StringKey<GetCustomHandler<Options>>;

// @public (undocumented)
export type CustomHandlerKeyList<Options extends ValidOptions> = Array<CustomHandlerKey<Options>>;

// @public (undocumented)
export type CustomHandlerShape<Type extends Shape> = {
    [Key in keyof Type]: CustomHandler<Type[Key]>;
};

// @public (undocumented)
export type Decoration = Decoration_2;

// @public (undocumented)
export type DecorationSet<Schema extends EditorSchema = any> = DecorationSet_2<Schema>;

// @public
export type DeepPartial<Type> = Type extends object ? {
    [K in keyof Type]?: DeepPartial<Type[K]>;
} : Type;

// @public
export type DeepString<Type> = Type extends object ? {
    [K in keyof Type]: DeepString<Type[K]>;
} : string;

// @public
export type Diff<A, B> = Omit<A, keyof B> & Omit<B, keyof A>;

// @public
export type DispatchFunction<Schema extends EditorSchema = any> = (tr: Transaction<Schema>) => void;

// @public
export type Dispose = () => void;

// @public (undocumented)
export interface DocParameter {
    doc: ProsemirrorNode;
}

// @public
export type DOMOutputSpec = string | [string, 0?] | [string, 0?] | [string, {
    [attr: string]: DOMCompatible;
}, 0?] | [string, DOMOutputSpecPos1?, DOMOutputSpecPosX?, DOMOutputSpecPosX?, DOMOutputSpecPosX?, DOMOutputSpecPosX?, DOMOutputSpecPosX?, DOMOutputSpecPosX?, DOMOutputSpecPosX?, DOMOutputSpecPosX?, DOMOutputSpecPosX?];

// @public
export type Dynamic<Type> = Type & DynamicAnnotation;

// @public (undocumented)
export type DynamicKey<Options extends ValidOptions> = StringKey<GetDynamic<Options>>;

// @public (undocumented)
export type DynamicKeyList<Options extends ValidOptions> = Array<DynamicKey<Options>>;

// @public (undocumented)
export type DynamicShape<Type extends object> = {
    [Key in keyof Type]: Dynamic<Type[Key]>;
};

// @public (undocumented)
export type EditorSchema<Nodes extends string = string, Marks extends string = string> = Schema<Nodes, Marks>;

// @public (undocumented)
export type EditorState<Schema extends EditorSchema = EditorSchema> = Readonly<EditorState_2<Schema>>;

// @public
export interface EditorStateParameter<Schema extends EditorSchema = EditorSchema> {
    state: EditorState<Schema>;
}

// @public (undocumented)
export type EditorView<Schema extends EditorSchema = any> = EditorView_2<Schema>;

// @public
export interface EditorViewParameter<Schema extends EditorSchema = EditorSchema> {
    view: EditorView<Schema>;
}

// @public
export interface ElementParameter {
    element: HTMLElement;
}

// @public
export type EmptyShape = Record<never, never>;

// @public
export type Flavor<Type, F> = Type & Flavoring<F>;

// @public
export interface Flavoring<Flavor> {
    // (undocumented)
    readonly [_flavor]?: Flavor;
}

// @public
export type FlipPartialAndRequired<Type extends object> = PickPartial<Type> & Partial<PickRequired<Type>>;

// @public (undocumented)
export type Fragment<Schema extends EditorSchema = any> = Fragment_2<Schema>;

// @public
export interface FromToParameter {
    from: number;
    to: number;
}

// @public
export type GetAttributes = ProsemirrorAttributes | GetAttributesFunction;

// @public (undocumented)
export interface GetAttributesParameter {
    getAttributes: GetAttributes;
}

// @public
export type GetConstructorParameter<Options extends ValidOptions> = GetStatic<Options> & GetDynamic<Options>;

// @public
export type GetCustomHandler<Options extends Shape> = ConditionalPick<Options, CustomHandlerAnnotation> & Partial<ConditionalPick<PickPartial<Options>, CustomHandlerAnnotation>>;

// @public
export type GetDynamic<Options extends Shape> = Omit<ConditionalExcept<Options, Exclude<Remirror.ValidOptionsExtender[keyof Remirror.ValidOptionsExtender], DynamicAnnotation>>, keyof ConditionalPick<PickPartial<Options>, Exclude<Remirror.ValidOptionsExtender[keyof Remirror.ValidOptionsExtender], DynamicAnnotation>>>;

// @public (undocumented)
export type GetFixed<Options extends ValidOptions> = Readonly<Required<Options>>;

// @public (undocumented)
export type GetFixedCustomHandler<Options extends ValidOptions> = Readonly<Required<GetCustomHandler<Options>>>;

// @public (undocumented)
export type GetFixedDynamic<Options extends ValidOptions> = Readonly<Required<GetDynamic<Options>>>;

// @public (undocumented)
export type GetFixedProps<Options extends ValidOptions> = GetFixedDynamic<Options> & GetFixedStatic<Options>;

// @public (undocumented)
export type GetFixedStatic<Options extends ValidOptions> = Readonly<Required<GetStatic<Options>>>;

// @public (undocumented)
export type GetFlippedStatic<Options extends ValidOptions> = FlipPartialAndRequired<Options>;

// @public
export type GetHandler<Options extends Shape> = ConditionalPick<Options, HandlerAnnotation> & Partial<ConditionalPick<PickPartial<Options>, HandlerAnnotation>>;

// @public (undocumented)
export type GetMappedCustomHandler<Options extends ValidOptions> = {
    [Key in keyof GetCustomHandler<Options>]: Array<GetCustomHandler<Options>[Key]>;
};

// @public (undocumented)
export type GetMappedHandler<Options extends ValidOptions> = {
    [Key in keyof GetHandler<Options>]: Array<GetHandler<Options>[Key]>;
};

// @public (undocumented)
export type GetPartialDynamic<Options extends ValidOptions> = Partial<GetDynamic<Options>>;

// @public
export type GetRequiredKeys<Type extends object> = keyof ConditionalPick<KeepPartialProperties<Type>, NeverBrand>;

// @public
export type GetStatic<Options extends Shape> = ConditionalPick<Options, StaticAnnotation> & Partial<ConditionalPick<PickPartial<Options>, StaticAnnotation>>;

// @public
export type GetStaticAndDynamic<Options extends Shape> = GetDynamic<Options> & GetStatic<Options>;

// @public
export type Handler<Type extends AnyFunction<void>> = Type & HandlerAnnotation;

// @public (undocumented)
export type HandlerKey<Options extends ValidOptions> = StringKey<GetHandler<Options>>;

// @public (undocumented)
export type HandlerKeyList<Options extends ValidOptions> = Array<HandlerKey<Options>>;

// @public (undocumented)
export type HandlerShape<Type extends Shape> = {
    [Key in keyof Type]: Handler<Type[Key]>;
};

// @public
export type IfEmpty<Type extends object, Then, Else> = keyof Type extends never ? Then : Else;

// @public
export type IfHasRequiredProperties<Type extends object, Then, Else> = IfNoRequiredProperties<Type, Else, Then>;

// @public
export type IfMatches<A, B, Then, Else> = IfEmpty<Diff<A, B>, Then, Else>;

// @public
export type IfNoRequiredProperties<Type extends object, Then, Else> = GetRequiredKeys<Type> extends NeverBrand ? Then : Else;

// @public (undocumented)
export type InputRule<Schema extends EditorSchema = any> = InputRule_2<Schema>;

// @public
export type KeepPartialProperties<Type extends object> = {
    [Key in keyof Type]: Type[Key] extends undefined ? Type[Key] : NeverBrand;
};

// @public
export type KeyBindingCommandFunction<Schema extends EditorSchema = any> = CommandFunction<Schema, NextParameter<Schema>>;

// @public
export type KeyBindings<Schema extends EditorSchema = EditorSchema> = Record<string, KeyBindingCommandFunction<Schema>>;

// @public
export type Literal = string | number | boolean | undefined | null | void | object;

// @public
export type MakeNullable<Type extends object, Keys extends keyof Type> = Omit<Type, Keys> & {
    [Key in Keys]: Type[Key] | null;
};

// @public
export type MakeOptional<Type extends object, Keys extends keyof Type> = Omit<Type, Keys> & {
    [Key in Keys]+?: Type[Key];
};

// @public
export type MakeReadonly<Type extends object, Keys extends keyof Type> = Omit<Type, Keys> & {
    +readonly [Key in Keys]: NonNullable<Type[Key]>;
};

// @public
export type MakeRequired<Type extends object, Keys extends keyof Type> = Omit<Type, Keys> & {
    [Key in Keys]-?: Type[Key];
};

// @public (undocumented)
export type Mapping = Mapping_2;

// @public (undocumented)
export type Mark<Schema extends EditorSchema = any> = Mark_2<Schema>;

// @public
export interface MarkExtensionSpec extends Pick<MarkSpec, 'attrs' | 'inclusive' | 'excludes' | 'group' | 'spanning' | 'parseDOM'> {
    toDOM?: (mark: Mark, inline: boolean) => DOMOutputSpec;
}

// @public (undocumented)
export type MarkType<Schema extends EditorSchema = any> = MarkType_2<Schema>;

// @public
export interface MarkTypeParameter<Schema extends EditorSchema = EditorSchema> {
    type: MarkType<Schema>;
}

// @public
export interface MarkTypesParameter<Schema extends EditorSchema = EditorSchema> {
    types: MarkType<Schema> | Array<MarkType<Schema>>;
}

// @public (undocumented)
export interface NextParameter<Schema extends EditorSchema = any> extends CommandFunctionParameter<Schema> {
    next: () => boolean;
}

// @public
export interface NodeExtensionSpec extends Pick<NodeSpec, 'content' | 'marks' | 'group' | 'inline' | 'atom' | 'attrs' | 'selectable' | 'draggable' | 'code' | 'defining' | 'isolating' | 'parseDOM' | 'toDebugString'> {
    toDOM?: (node: ProsemirrorNode) => DOMOutputSpec;
}

// @public (undocumented)
export interface NodeMarkOptions {
    // (undocumented)
    mark?: Mark;
    // (undocumented)
    node?: ProsemirrorNode;
}

// @public
export type NodeMatch<Schema extends EditorSchema = any> = string | ((name: string, node: ProsemirrorNode<Schema>) => boolean) | RegexTuple;

// @public (undocumented)
export type NodeType<Schema extends EditorSchema = any> = NodeType_2<Schema>;

// @public
export interface NodeTypeParameter<Schema extends EditorSchema = EditorSchema> {
    type: NodeType<Schema>;
}

// @public
export interface NodeTypesParameter<Schema extends EditorSchema = EditorSchema> {
    types: NodeType<Schema> | string | Array<NodeType<Schema> | string>;
}

// @public (undocumented)
export type NodeView<Schema extends EditorSchema = any> = NodeView_2<Schema>;

// @public
export type NodeViewMethod<View extends NodeView_2 = NodeView_2> = (node: ProsemirrorNode, view: EditorView, getPos: (() => number) | boolean, decorations: Decoration_2[]) => View;

// @public (undocumented)
export type NodeWithAttributes<NodeAttributes extends ProsemirrorAttributes = ProsemirrorAttributes> = ProsemirrorNode & {
    attrs: NodeAttributes;
};

// @public (undocumented)
export interface NodeWithAttributesParameter<NodeAttributes extends ProsemirrorAttributes = ProsemirrorAttributes> {
    node: NodeWithAttributes<NodeAttributes>;
}

// @public (undocumented)
export type NonNullableShape<Type extends object> = {
    [Key in keyof Type]: NonNullable<Type[Key]>;
};

// @public
export type Nullable<Type> = Type | null | undefined;

// @public
export interface ObjectMark {
    // (undocumented)
    attrs?: Record<string, string | null>;
    // (undocumented)
    type: string;
}

// @public
export type OptionalFromToParameter<Key extends keyof FromToParameter> = MakeOptional<FromToParameter, Key>;

// @public (undocumented)
export interface OptionalMarkParameter<Schema extends EditorSchema = EditorSchema> {
    mark: Mark<Schema> | null | undefined;
}

// @public (undocumented)
export interface OptionalProsemirrorNodeParameter<Schema extends EditorSchema = EditorSchema> {
    node: ProsemirrorNode<Schema> | null | undefined;
}

// @public
export type PartialWithRequiredKeys<Type extends object, Keys extends keyof Type> = Partial<Pick<Type, Exclude<keyof Type, Keys>>> & Required<Pick<Type, Keys>>;

// @public
export type PickPartial<Type extends object> = {
    [Key in keyof ConditionalExcept<KeepPartialProperties<Type>, NeverBrand>]-?: Type[Key];
};

// @public
export type PickRequired<Type extends object> = {
    [Key in keyof ConditionalPick<KeepPartialProperties<Type>, NeverBrand>]: Type[Key];
};

// @public (undocumented)
type Plugin_2<PluginState = any, Schema extends EditorSchema = any> = Plugin_3<PluginState, Schema>;

export { Plugin_2 as Plugin }

// @public (undocumented)
export type PluginKey<PluginState = any> = PluginKey_2<PluginState, EditorSchema>;

// @public
interface Position_2 {
    // (undocumented)
    bottom: number;
    // (undocumented)
    left: number;
    // (undocumented)
    right: number;
    // (undocumented)
    top: number;
}

export { Position_2 as Position }

// @public
export interface PositionParameter {
    position: Position_2;
}

// @public (undocumented)
export interface PosParameter {
    pos: number;
}

// @public
export type Predicate<Type> = (value: unknown) => value is Type;

// @public (undocumented)
export interface PredicateParameter<Parameter> {
    predicate: (parameter: Parameter) => boolean;
}

// @public
export interface PreviousNextParameter<Type> {
    next: Type;
    previous: Type;
}

// @public
export type PrimitiveSelection = Selection_2 | FromToParameter | number | 'start' | 'end';

// @public
export type ProsemirrorAttributes<Extra extends object = object> = Record<string, unknown> & Extra;

// @public
export type ProsemirrorCommandFunction<Schema extends EditorSchema = any> = (state: EditorState<Schema>, dispatch: DispatchFunction<Schema> | undefined, view: EditorView<Schema> | undefined) => boolean;

// @public (undocumented)
export type ProsemirrorKeyBindings<Schema extends EditorSchema = EditorSchema> = Record<string, ProsemirrorCommandFunction<Schema>>;

// @public (undocumented)
export type ProsemirrorNode<Schema extends EditorSchema = any> = Node_2<Schema>;

// @public (undocumented)
export interface ProsemirrorNodeParameter<Schema extends EditorSchema = EditorSchema> {
    node: ProsemirrorNode<Schema>;
}

// @public (undocumented)
export type ProsemirrorPlugin<PluginState = any> = Plugin_3<PluginState, EditorSchema>;

// @public (undocumented)
export interface RangeParameter<Key extends keyof FromToParameter = never> {
    range: OptionalFromToParameter<Key>;
}

// @public (undocumented)
export interface RegExpParameter {
    regexp: RegExp;
}

// @public
export type RegexTuple = [string, string?];

// @public
export type RemirrorContentType<Schema extends EditorSchema = any> = string | RemirrorJSON | ProsemirrorNode<Schema> | EditorState<Schema>;

// @public
export interface RemirrorIdentifierShape {
    // (undocumented)
    [__INTERNAL_REMIRROR_IDENTIFIER_KEY__]: RemirrorIdentifier;
}

// @public
export interface RemirrorJSON {
    // (undocumented)
    attrs?: Record<string, Literal | object>;
    // (undocumented)
    content?: RemirrorJSON[];
    // (undocumented)
    marks?: Array<ObjectMark | string>;
    // (undocumented)
    text?: string;
    // (undocumented)
    type: string;
}

// @public (undocumented)
export type RemoveAnnotation<Type> = RemoveFlavoring<Type>;

// @public
export type RemoveFlavoring<Type> = Omit<Type, typeof _flavor>;

// @public
export type RenderEnvironment = 'ssr' | 'dom';

// @public
export type Replace<Type, Replacements extends Shape> = Omit<Type, keyof Replacements> & Replacements;

// @public (undocumented)
export type ResolvedPos<Schema extends EditorSchema = any> = ResolvedPos_2<Schema>;

// @public (undocumented)
export interface ResolvedPosParameter<Schema extends EditorSchema = EditorSchema> {
    $pos: ResolvedPos<Schema>;
}

// @public
export type SchemaAttributes = Record<string, SchemaAttributesObject | string>;

// @public (undocumented)
export interface SchemaAttributesObject {
    default: string | null;
    parseDOM?: ((domNode: HTMLElement) => unknown) | string;
    toDOM?: string | [string, string?] | ((attrs: ProsemirrorAttributes, options: NodeMarkOptions) => string | [string, string?] | null | undefined);
}

// @public
export interface SchemaParameter<Nodes extends string = string, Marks extends string = string> {
    schema: EditorSchema<Nodes, Marks>;
}

// @public (undocumented)
type Selection_2<Schema extends EditorSchema = any> = Selection_3<Schema>;

export { Selection_2 as Selection }

// @public (undocumented)
export interface SelectionParameter<Schema extends EditorSchema = EditorSchema> {
    selection: Selection_2<Schema>;
}

// @public
export interface Shape {
    // (undocumented)
    [key: string]: any;
}

// @public (undocumented)
export type Slice<Schema extends EditorSchema = any> = Slice_2<Schema>;

// @public (undocumented)
export interface StateJSON {
    // (undocumented)
    [key: string]: unknown;
    // (undocumented)
    doc: RemirrorJSON;
    // (undocumented)
    selection: FromToParameter;
}

// @public (undocumented)
export interface StateOrTransactionParameter<Schema extends EditorSchema = EditorSchema> {
    stateOrTransaction: EditorState<Schema> | Transaction<Schema>;
}

// @public
export type Static<Type> = Type & StaticAnnotation;

// @public (undocumented)
export type StaticKey<Options extends ValidOptions> = StringKey<GetStatic<Options>>;

// @public (undocumented)
export type StaticKeyList<Options extends ValidOptions> = Array<StaticKey<Options>>;

// @public (undocumented)
export type StaticShape<Type extends object> = {
    [Key in keyof Type]: Static<Type[Key]>;
};

// @public
export type StrictReplace<Type, Replacements extends Record<keyof Type, unknown>> = Omit<Type, keyof Replacements> & Replacements;

// @public
export type StringKey<Type> = Extract<keyof Type, string>;

// @public (undocumented)
export interface TextParameter {
    text: string;
}

// @public (undocumented)
export type Transaction<Schema extends EditorSchema = any> = Transaction_2<Schema>;

// @public (undocumented)
export interface TransactionLifecycle {
    after: TransactionTransformer;
    before: TransactionTransformer;
}

// @public (undocumented)
export interface TransactionParameter<Schema extends EditorSchema = EditorSchema> {
    tr: Transaction<Schema>;
}

// @public
export type TransactionTransformer<Schema extends EditorSchema = EditorSchema> = (tr: Transaction<Schema>, state: EditorState<Schema>) => Transaction<Schema>;

// @public
export type TupleValue<Tuple extends readonly unknown[]> = Tuple[number];

// @public
export type UndefinedFlipPartialAndRequired<Type extends object> = UndefinedPickPartial<Type> & Partial<PickRequired<Type>>;

// @public
export type UndefinedPickPartial<Type extends object> = {
    [Key in keyof PickPartial<Type>]: PickPartial<Type>[Key] | undefined;
};

// @public
export type UnknownShape<Type = unknown> = Record<string, Type>;

// @public
export interface ValidOptions {
    // (undocumented)
    [option: string]: any;
}

// @public
export type Value<Type> = Type[keyof Type];

// @public
export type Writeable<Type> = {
    -readonly [Key in keyof Type]: Type[Key];
};


// (No @packageDocumentation comment for this package)

```
