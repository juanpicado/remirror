## API Report File for "@remirror/core-utils"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { AttributesParameter } from '@remirror/core-types';
import type { Brand } from '@remirror/core-types';
import type { CommandFunction } from '@remirror/core-types';
import type { CommandFunctionParameter } from '@remirror/core-types';
import type { EditorSchema } from '@remirror/core-types';
import type { EditorState } from '@remirror/core-types';
import { EditorState as EditorState_2 } from '@remirror/pm/state';
import type { EditorView } from '@remirror/core-types';
import type { ElementParameter } from '@remirror/core-types';
import type { EmptyShape } from '@remirror/core-types';
import type { Fragment } from '@remirror/core-types';
import type { FromToParameter } from '@remirror/core-types';
import type { GetAttributesParameter } from '@remirror/core-types';
import { InputRule } from '@remirror/pm/inputrules';
import type { KeyBindingCommandFunction } from '@remirror/core-types';
import type { KeyBindings } from '@remirror/core-types';
import { Mark } from '@remirror/pm/model';
import type { MarkSpec } from '@remirror/pm/model';
import type { MarkType } from '@remirror/core-types';
import { MarkType as MarkType_2 } from '@remirror/pm/model';
import type { MarkTypeParameter } from '@remirror/core-types';
import type { MarkTypesParameter } from '@remirror/core-types';
import type { NodeMatch } from '@remirror/core-types';
import { NodeSelection } from '@remirror/pm/state';
import type { NodeSpec } from '@remirror/pm/model';
import type { NodeType } from '@remirror/core-types';
import { NodeType as NodeType_2 } from '@remirror/pm/model';
import type { NodeTypeParameter } from '@remirror/core-types';
import type { NodeTypesParameter } from '@remirror/core-types';
import type { OptionalMarkParameter } from '@remirror/core-types';
import type { OptionalProsemirrorNodeParameter } from '@remirror/core-types';
import { Plugin as Plugin_2 } from '@remirror/pm/state';
import type { PluginKey } from '@remirror/core-types';
import type { PosParameter } from '@remirror/core-types';
import type { PredicateParameter } from '@remirror/core-types';
import type { PrimitiveSelection } from '@remirror/core-types';
import type { ProsemirrorAttributes } from '@remirror/core-types';
import type { ProsemirrorCommandFunction } from '@remirror/core-types';
import type { ProsemirrorKeyBindings } from '@remirror/core-types';
import type { ProsemirrorNode } from '@remirror/core-types';
import type { ProsemirrorNodeParameter } from '@remirror/core-types';
import type { RangeParameter } from '@remirror/core-types';
import type { RegExpParameter } from '@remirror/core-types';
import type { RemirrorContentType } from '@remirror/core-types';
import type { RemirrorJSON } from '@remirror/core-types';
import type { RenderEnvironment } from '@remirror/core-types';
import type { ResolvedPos } from '@remirror/core-types';
import { ResolvedPos as ResolvedPos_2 } from '@remirror/pm/model';
import { Schema } from '@remirror/pm/model';
import type { SchemaParameter } from '@remirror/core-types';
import type { Selection as Selection_2 } from '@remirror/core-types';
import { Selection as Selection_3 } from '@remirror/pm/state';
import type { SelectionParameter } from '@remirror/core-types';
import type { Shape } from '@remirror/core-types';
import { Slice } from '@remirror/pm/model';
import type { StateOrTransactionParameter } from '@remirror/core-types';
import { TextSelection } from '@remirror/pm/state';
import type { Transaction } from '@remirror/core-types';
import { Transaction as Transaction_2 } from '@remirror/pm/state';
import type { TransactionParameter } from '@remirror/core-types';

// @public
export const ALT: readonly ["Alt", "⌥"];

// @public
export function applyClonedTransaction(parameter: ApplyClonedTransactionParameter): void;

// @public
export function areSchemaCompatible(schemaA: EditorSchema, schemaB: EditorSchema): boolean;

// @public
export function atDocEnd(state: EditorState): boolean;

// @public
export function atDocStart(state: EditorState): boolean;

// @public
export function canInsertNode(state: EditorState, type: NodeType_2): boolean;

// @public
export const CAPS_LOCK: string[];

// @public
export function chainCommands<Schema extends EditorSchema = any, Extra extends object = object>(...commands: Array<CommandFunction<Schema, Extra>>): CommandFunction<Schema, Extra>;

// @public
export function chainKeyBindingCommands(...commands: KeyBindingCommandFunction[]): KeyBindingCommandFunction;

// @public
export function cloneTransaction(tr: Transaction): Transaction;

// @public
export function closestElement(domNode: Node | null | undefined, selector: string): HTMLElement | null;

// @public
export const COMMAND: readonly ["Meta", "⌘"];

// @public
export function containsNodesOfType(parameter: ContainsParameter): boolean;

// @public
export function convertCommand<Schema extends EditorSchema = any, Extra extends Shape = EmptyShape>(commandFunction: ProsemirrorCommandFunction<Schema>): NonChainableCommandFunction<Schema, Extra>;

// @public (undocumented)
export type CreateDocumentErrorHandler = (error?: Error) => Fallback;

// @public
export function createDocumentNode(parameter: CreateDocumentNodeParameter): ProsemirrorNode;

// @public (undocumented)
export interface CreateDocumentNodeParameter extends SchemaParameter, Partial<CustomDocParameter>, StringHandlerParameter {
    content: RemirrorContentType;
    onError?: Fallback | CreateDocumentErrorHandler;
    selection?: PrimitiveSelection;
}

// @public
export const CTRL: readonly ["Control", "⌃"];

// @public
export const emptyCommandFunction: ProsemirrorCommandFunction;

// @public
export function endPositionOfParent(pmPosition: ResolvedPos): number;

// @public
export const environment: {
    readonly isBrowser: boolean;
    readonly isJSDOM: boolean;
    readonly isNode: boolean;
    readonly isMac: boolean;
    readonly isApple: boolean;
    readonly isDevelopment: boolean;
    readonly isTest: boolean;
    readonly isProduction: boolean;
};

// @public (undocumented)
export type Fallback = RemirrorJSON | ProsemirrorNode;

// @public
export const findBlockNodes: (parameters: FlattenParameter) => NodeWithPosition[];

// @public
export function findChildren(parameter: FindChildrenParameter): NodeWithPosition[];

// @public
export function findChildrenByAttribute(parameter: FindChildrenByAttrParameter): NodeWithPosition[];

// @public
export function findChildrenByMark(paramter: FindChildrenByMarkParameter): NodeWithPosition[];

// @public
export function findChildrenByNode(parameter: FindChildrenByNodeParameter): NodeWithPosition[];

// @public
export function findElementAtPosition(position: number, view: EditorView): HTMLElement;

// @public
export const findInlineNodes: (parameters: FlattenParameter) => NodeWithPosition[];

// @public
export function findNodeAtPosition($pos: ResolvedPos): FindProsemirrorNodeResult;

// @public
export function findNodeAtSelection(selection: Selection_2): FindProsemirrorNodeResult;

// @public
export function findParentNode(parameter: FindParentNodeParameter): FindProsemirrorNodeResult | undefined;

// @public
export function findParentNodeOfType(parameter: FindParentNodeOfTypeParameter): FindProsemirrorNodeResult | undefined;

// @public
export function findPositionOfNodeAfter<Schema extends EditorSchema = any>(value: Selection_2<Schema> | ResolvedPos<Schema> | EditorState<Schema>): FindProsemirrorNodeResult | undefined;

// @public
export function findPositionOfNodeBefore<Schema extends EditorSchema = any>(value: Selection_2<Schema> | ResolvedPos<Schema> | EditorState<Schema> | Transaction<Schema>): FindProsemirrorNodeResult | undefined;

// @public (undocumented)
export interface FindProsemirrorNodeResult<Schema extends EditorSchema = any> extends ProsemirrorNodeParameter<Schema> {
    depth: number;
    end: number;
    pos: number;
    start: number;
}

// @public (undocumented)
export interface FindSelectedNodeOfType<Schema extends EditorSchema = any> extends FindProsemirrorNodeResult<Schema> {
    depth: number;
}

// @public
export function findSelectedNodeOfType<Schema extends EditorSchema = any>(parameter: FindSelectedNodeOfTypeParameter<Schema>): FindSelectedNodeOfType<Schema> | undefined;

// @public
export const findTextNodes: (parameters: FlattenParameter) => NodeWithPosition[];

// @public
export function flatten(parameter: FlattenParameter): NodeWithPosition[];

// @public
export function fromHtml(parameter: FromStringParameter): ProsemirrorNode;

// @public
export function getCursor(selection: Selection_2): ResolvedPos | null | undefined;

// @public
export function getDocument(forceEnvironment?: RenderEnvironment): any;

// @public
export function getLineHeight({ element }: ElementParameter): number;

// @public
export function getMarkAttributes(state: EditorState, type: MarkType_2): {
    [key: string]: any;
};

// @public
export function getMarkRange(pmPosition?: ResolvedPos | null, type?: MarkType_2 | null | undefined): FromToParameter | false;

// @public
export function getMatchString(match: string | string[], index?: number): string;

// @public
export function getNearestNonTextNode(domNode: Node): HTMLElement;

// @public
export function getPluginMeta<Meta>(key: PluginKey | Plugin_2 | string, tr: Transaction): Meta;

// @public
export function getPluginState<State>(plugin: Plugin_2 | PluginKey, state: EditorState): State;

// @public
export function getRemirrorJSON(state: EditorState): RemirrorJSON;

// @public
export function getSelectedGroup(stateOrTransaction: EditorState | Transaction, exclude: RegExp): FromToParameter | false;

// @public
export function getSelectedWord(stateOrTransaction: EditorState | Transaction): false | FromToParameter;

// @public
export function getTextContentFromSlice(slice: Slice): string;

// @public
export function getTextSelection(selection: PrimitiveSelection, doc: ProsemirrorNode): TextSelection;

// @public
export function hasTransactionChanged(tr: Transaction): boolean;

// @public
export function isApple(): boolean;

// @public
export function isDocNode(node: ProsemirrorNode | null | undefined, schema?: EditorSchema): boolean;

// @public
export function isDocNodeEmpty(node: ProsemirrorNode): boolean;

// @public
export function isDomNode(domNode: unknown): domNode is Node;

// @public
export function isEditorSchema<Nodes extends string = string, Marks extends string = string>(value: unknown): value is Schema<Nodes, Marks>;

// @public
export function isEditorState<Schema extends EditorSchema = EditorSchema>(value: unknown): value is EditorState_2<Schema>;

// @public
export function isElementDomNode(domNode: unknown): domNode is HTMLElement;

// @public
export function isMarkActive<Schema extends EditorSchema = EditorSchema>(parameter: IsMarkActiveParameter<Schema>): boolean;

// @public
export function isMarkType<Schema extends EditorSchema = EditorSchema>(value: unknown): value is MarkType_2<Schema>;

// @public
export function isNodeActive(parameter: IsNodeActiveParameter): boolean;

// @public
export function isNodeOfType<Schema extends EditorSchema = any>(parameter: NodeEqualsTypeParameter<Schema>): boolean;

// @public
export function isNodeSelection<Schema extends EditorSchema = EditorSchema>(value: unknown): value is NodeSelection<Schema>;

// @public
export function isNodeType<Schema extends EditorSchema = EditorSchema>(value: unknown): value is NodeType_2<Schema>;

// @public
export function isProsemirrorMark<Schema extends EditorSchema = EditorSchema>(value: unknown): value is Mark<Schema>;

// @public
export function isProsemirrorNode<Schema extends EditorSchema = EditorSchema>(value: unknown): value is ProsemirrorNode<Schema>;

// @public
export function isRemirrorJSON(value: unknown): value is RemirrorJSON;

// @public
export function isResolvedPos<Schema extends EditorSchema = EditorSchema>(value: unknown): value is ResolvedPos_2<Schema>;

// @public
export function isSelection<Schema extends EditorSchema = EditorSchema>(value: unknown): value is Selection_3<Schema>;

// @public
export function isSelectionEmpty(value: Transaction | EditorState | Selection_2): boolean;

// @public
export function isStateEqual(stateA: EditorState, stateB: EditorState, options?: IsStateEqualOptions): boolean;

// @public
export function isTextDomNode(domNode: unknown): domNode is Text;

// @public
export function isTextSelection<Schema extends EditorSchema = EditorSchema>(value: unknown): value is TextSelection<Schema>;

// @public
export function isTransaction<Schema extends EditorSchema = EditorSchema>(value: unknown): value is Transaction_2<Schema>;

// @public
export function lift({ tr, dispatch }: Pick<CommandFunctionParameter, 'tr' | 'dispatch'>): boolean;

// @public
export function markEqualsType<Schema extends EditorSchema = any>(parameter: MarkEqualsTypeParameter<Schema>): boolean;

// @public
export function markInputRule(parameter: MarkInputRuleParameter): InputRule<any>;

// @public
export function markPasteRule(parameter: MarkInputRuleParameter): Plugin_2<any, any>;

// @public
export function mergeKeyBindings<Schema extends EditorSchema = any>(extensionKeymaps: Array<KeyBindings<Schema>>): KeyBindings<Schema>;

// @public
export function mergeProsemirrorKeyBindings<Schema extends EditorSchema = any>(extensionKeymaps: Array<KeyBindings<Schema>>): ProsemirrorKeyBindings<Schema>;

// @public
export function mod(modifier: ModifierKeys, key: string, isMacFn?: typeof isApple): string;

// @public
export const Modifier: {
    Primary: (isMac?: boolean) => "Meta"[] | "Control"[];
    PrimaryShift: (isMac?: boolean) => ("Shift" | "Meta")[] | ("Shift" | "Control")[];
    PrimaryAlt: (isMac?: boolean) => ("Alt" | "Meta")[] | ("Control" | "Alt")[];
    Secondary: (isMac?: boolean) => ("Shift" | "Alt" | "Meta")[] | ("Shift" | "Control" | "Alt")[];
    Access: (isMac?: boolean) => ("Control" | "Alt")[] | ("Shift" | "Alt")[];
    Ctrl: () => "Control"[];
    Alt: () => "Alt"[];
    CtrlShift: () => ("Shift" | "Control")[];
    Shift: () => "Shift"[];
    ShiftAlt: () => ("Shift" | "Alt")[];
};

// @public
export type ModifierKeys = keyof typeof Modifier;

// @public
export function nodeInputRule(parameter: NodeInputRuleParameter): InputRule<any>;

// @public
export function nodeNameMatchesList(node: ProsemirrorNode | null | undefined, nodeMatches: NodeMatch[]): node is ProsemirrorNode;

// @public
export interface NodeWithPosition extends ProsemirrorNodeParameter, PosParameter {
}

// @public
export function nonChainable<Schema extends EditorSchema = any, Extra extends Shape = EmptyShape>(commandFunction: CommandFunction<Schema, Extra>): NonChainableCommandFunction<Schema, Extra>;

// @public
export type NonChainableCommandFunction<Schema extends EditorSchema = any, Extra extends Shape = EmptyShape> = Brand<CommandFunction<Schema, Extra>, 'non-chainable'>;

// @public
export function plainInputRule(parameter: PlainInputRuleParameter): InputRule<any>;

// @public
export function removeMark(parameter: RemoveMarkParameter): CommandFunction;

// @public
export function removeNodeAfter(tr: Transaction): Transaction<any>;

// @public
export function removeNodeAtPosition({ pos, tr }: RemoveNodeAtPositionParameter): Transaction<EditorSchema<string, string>>;

// @public
export function removeNodeBefore(tr: Transaction): Transaction<any>;

// @public
export function replaceNodeAtPosition({ pos, tr, content }: ReplaceNodeAtPositionParameter): Transaction<EditorSchema<string, string>>;

// @public
export function replaceText(parameter: ReplaceTextParameter): CommandFunction;

// @public (undocumented)
export interface SchemaJSON<Nodes extends string = string, Marks extends string = string> {
    // (undocumented)
    marks: Record<Marks, MarkSpec>;
    // (undocumented)
    nodes: Record<Nodes, NodeSpec>;
}

// @public
export function schemaToJSON<Nodes extends string = string, Marks extends string = string>(schema: EditorSchema<Nodes, Marks>): SchemaJSON<Nodes, Marks>;

// @public
export function setBlockType(type: NodeType, attrs?: ProsemirrorAttributes): CommandFunction;

// @public
export function setPluginMeta<Meta>(key: PluginKey | Plugin_2 | string, tr: Transaction, data: Meta): Transaction;

// @public
export const SHIFT: readonly ["Shift", "⇧"];

// @public
export function shouldUseDomEnvironment(forceEnvironment?: RenderEnvironment): boolean;

// @public
export function startPositionOfParent(pmPosition: ResolvedPos): number;

// @public (undocumented)
export interface StringHandlerParameter {
    stringHandler?: (params: FromStringParameter) => ProsemirrorNode;
}

// @public
export function toDom({ node, schema, doc }: FromNodeParameter): DocumentFragment;

// @public
export function toggleBlockItem(toggleParameter: ToggleBlockItemParameter): CommandFunction;

// @public
export function toggleList(type: NodeType, itemType: NodeType): CommandFunction;

// @public
export function toggleWrap(type: NodeType, attrs?: ProsemirrorAttributes): CommandFunction;

// @public
export function toHtml({ node, schema, doc }: FromNodeParameter): string;

// @public
export function updateMark(parameter: UpdateMarkParameter): CommandFunction;

// @public
export const WINDOWS: string[];

// @public
export function wrapIn(type: NodeType, attrs: ProsemirrorAttributes): CommandFunction;


// (No @packageDocumentation comment for this package)

```
